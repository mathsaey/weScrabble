import /.at.lang.types;
import /.at.lang.exceptions;

import ~.dictionary;
import ~.utils;

deftype MaximumTeamsReached <: lobby.at.lang.types.Exception;
def  XMaximumTeamsReached := createException(MaximumTeamsReached);

// Represents the game for a single player
def playerGame := object: { 
	// Each player has a name
	def name := "";
	// The rack contains the word being formed
	def rack := createRack(); 
	// The letters contain all the letters currently in play
	def letters := getRandomLetters: ~.constants.LETTER_AMOUNT;

	def init(playerName) {
		name := playerName;
		rack := createRack();
		letters := getRandomLetters: ~.constants.LETTER_AMOUNT;
	}; 
};

// Represents a team of players
def team := object: {
	// Team name
	def name := "";
	// Reference to every player that 
	// the local game knows
	def players := [];

	// Add a reference to the player
	def addPlayer: player {
		players + [player];
	};

	// Creates a new team
	def init(newName) {
		name := newName
	};
};

// Represents the entire game
def game := object: {
	// identifier unique to the game
	def id;
	// Contains all teams
	def teams;

	def init() {
		id := generateID();
		teams := [];
	};

	// Add a team to the game if there is room
	def addTeam(name) {
		if: teams.length >= ~.constants.TEAM_AMOUNT 
		then: {
			raise: XMaximumTeamsReached.new("This game already has enough teams!");
		} else: {
			teams := teams + [team.new(name)];
		};
	};
	// Creates a team for each entry in a table
	def addTeams(names) {
		foreach: {|t| addTeam(t)} in: names;
	};

	// Java interfaces cannot access new
	def create() {
		self.new();
	};
};