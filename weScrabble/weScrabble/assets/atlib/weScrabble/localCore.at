// localCore.at
// Mathijs Saey
// The local core object is the general file that imports the different network 
// and local modules and calls them when necessary, it also contains the 
// local instance of the active game.

import ~.local.game;
import ~.local.team;
import ~.local.player;

import ~.network.merger;
import ~.network.exporter;
import ~.network.importer;

import /.at.lang.futures;

/*********
 * Core  *
 *********/


 // => in game timestamp bijhouden van laatste change
 // => listener aan kopellen via future, bij elke change reexporten

def core := object: { 
	def currentGame;
	def localPlayer;

	/************
	 * External *
	 ************/

	// Initialises the core with the player name
	def init(playerName) {
		// The player that creates a game
		// always starts on the first team
		// the idx is modified, if the player joins a game instead
		self.localPlayer := activePlayer.new(playerName,1);
		self;
	};

	// Start a new game
	def createGame(gameName, teamNames) {
		// Use the device id as unique identifier.
		//def parent := jlobby.edu.vub.at.android.util.IATAndroid.getInstance().getParentActivity();
		//def deviceID := parent.getDeviceID();
		def deviceID := "tmp";
		self.currentGame := game.new(gameName, teamNames, localPlayer, deviceID);
		self.startGame();
	};

	// Join a game (if it's in range)
	def joinGame(gameIdx, teamIdx) {
		localPlayer.teamIdx := teamIdx;
		when: importer.joinGame(gameIdx, self.localPlayer) becomes: { |game|
			currentGame := game;
			self.startGame();
		};
		nil;
	};

	// Get the names of the games that are in range
	def getGameNames() {
		importer.search();
		importer.gameNames();
	};

	// Forces reexporting the game,
	// this will cause any currently connected
	// game to re-merge with this one.
	def refresh() {
		self.exportGame();
	};

	/********
	 * Util *
	 ********/

	// Starts the necessary services
	// after the game has been joined/created
	def startGame() {
		self.runUpdater;
		self.exportGame;
		self;
	};

	// Export the current game
	// recalling this serves as a refresh
	// (when changing tags)
	def exportGame() {
		exporter.init(currentGame);
		exporter.export();
	};

	// Looks for other games and merges with them
	def runUpdater() {
		merger.runUpdater(self.currentGame);
	};

	/*********
	 * Debug *
	 *********/

	def exD() {
		self.init("Mathijs");
		self.createGame("Awesome game", ["FUCK YEAH MATHIJS", "ander team"]);
	};
	def inD(name) {
		self.init(name);
		self.getGameNames();
	};

	def dGetPlayers() {
		system.println(currentGame.teams[1].activePlayers);
		system.println(currentGame.teams[2].activePlayers);
	};

	def dGetNames(team) {
 		foreach: { |p|
 			 def fut := p<-name()@TwoWay;
 			 when: fut becomes: { |n|
 			 	system.println(n);
 			 }
 		} in: team.activePlayers;
 	};
};

// Debug
network.online();

/***************
 * Export List *
 ***************/

object: { 
	def core := core; 
};