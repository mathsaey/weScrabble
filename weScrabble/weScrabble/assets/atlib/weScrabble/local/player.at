// player.at
// Mathijs Saey
// This file contains the implementation of the player object

import /.at.lang.types;
import /.at.support.util;

import ~.constants;
import ~.dictionary;

/*********************
 * Utility Functions *
 *********************/

// Gets a random letter 
def getRandomLetter() {
	def idx := randomNumberBetween(1, CONSTANTS.ALPHABET.length());
	CONSTANTS.ALPHABET[idx];
};
// Returns a table of length n filled with random letters
def getRandomLetters(n) {
	def res [n];
	n.doTimes: {|i| res[i]:=getRandomLetter()};
	res;
};

// Returns (length/2) random letters from a word
def getThrowLetters(word) {
	def n := (word.length / 2).floor();
	def currentWord := word;
	def res := [];

	n.doTimes: {|i| 
		def idx := randomNumberBetween(1, currentWord.length());
		def let := currentWord[idx];
		currentWord[idx] := "_";
		currentWord := currentWord.filter:{|l| l != "_"};
		res := res + [let];
	};
	res;
};


// Create an empty rack
def createRack() {[]};
// Adds a letter to the rack (a table)
def addLetter(letter, rack) {
	rack := rack + [letter];
};
// returns a new table without the element at idx
def removeElement(table, idx) {
	table[idx] := "_";
	def res := table.filter: { |l|
		l != "_"
	};
};

/**********
 * Player *
 **********/

/**
 An activePlayer object represents a player that is still playing
*/
def activePlayer := object: {
	def isActive() {true};
};

/**
 A resolved player object represents a player that used all his letters
*/
def resolvedPlayer := object: {
	// the resolvetime represents when the game was resolved
	def resolveTime;

	def isActive() {false;};
};

/**
 An activePlayer object represents a player currently still playing
 the game, on top of the regular data, it also stores the rack and letters
*/
def player := extend: activePlayer with: {
	// Name of the player 
	def name;
	// idx of the team the player is in.
	def teamIdx;
	// The rack is the table that contains the word being formed
	def rack := [];
	// The letters is a table containing the letters the player still has to use
	def letters := [];

	def init(name, teamIdx) {
		self.name := name;
		self.teamIdx := teamIdx;
		self.rack := createRack();
		self.letters := getRandomLetters(CONSTANTS.LETTER_AMOUNT);
		self;
	};

	def resolve() {
		super := resolvedPlayer;
	};

	// Checks if the rack currently contains a valid word
	def checkRack() {
		findWord: rack.implode();
	};

	def emptyRack() {
		def res := false;
		if: (self.checkRack(self.rack)) then: {
			def word := self.rack;
			self.rack := [];
			res := getThrowLetters(word);
		};
		if: (letters == [])
		then: {self.resolve()};
		res;
	};

	def moveToRack(idx) {
		def let := letters[idx];
		rack := rack + [let];
		letters := removeElement(letters, idx);
	};

	def removeLetterFromRack() {
		def length := rack.length;
		def let := rack[length];
		letters := letters + [let];
		self.rack := rack.select(1, length - 1);
	};

	def addLetters(letters) {
		self.letters := self.letters + letters;
	};
	def removeLetterWithIdx(idx) {
		self.letters := removeElement(letters, idx);
	};
	def takeLetter(letter) {
		def idx := self.letters.find:{|e| e == letter};
		def res := letter;
		if: letter != nil then: {
			self.removeLetterWithIdx(idx);
		} else: {
			res := nil;
		};
		res;
	};
};

/***************
 * Export List *
 ***************/

object: {
	def player := player; 
	def activePlayer := activePlayer;
	def resolvedPlayer := resolvedPlayer; 
};