// game.at
// Mathijs Saey
// This file contains the implementation of the game object

import /.at.lang.exceptions;

import ~.team;
import ~.player;
import ~.constants;

// Exceptions
deftype MaximumTeamsReached <: lobby.at.lang.types.Exception;
def  XMaximumTeamsReached := createException(MaximumTeamsReached);

// Tag representing a game
deftype Game;
deftype ActiveGame <: Game;
deftype ResolvedGame <: Game;

/********
 * Game *
 ********/

/**
	A game represents the global state of the game stored by all players
*/
def game := object: {
	// Unique identifier of the game
	def id := "";
	// Checks if a check occured since the last time 
	// the variable was set
	def changeOccured := true;
	// Name chosen by the person that started the game
	// does not need to be unique
	def name;
	// Contains all the teams
	def teams := [];
	// Reference to the local player
	def localPlayer;

	// Initialise the game, 
	def init(name, teamNames, localPlayer, deviceID) {
		self.teams := [];
		self.name := name;
		self.id := generateID(deviceID);
		self.addTeams: teamNames;
		self.localPlayer := localPlayer;

		teams[localPlayer.teamIdx()].addPlayer: localPlayer;
		self;
	};

	def addPlayer: playerRef withIdx: idx {
		self.teams[idx].addPlayer: playerRef;
		changeOccured := true;
	};

	// Checks if any of the teams finished the game
	def didGameEnd() {
		teams.inject: false into: {|accum, e| accum.or:{e.didTeamResolve()}}
	};

	// Checks if the local player finished his/her game.
	def canJoinGame() {
		self.localPlayer.canJoinGame();
	};

	// Checks if 2 games are the same by matching id's
	def ==(other) {
		self.id == other.id;
	};

	// Add a team to the game if there is room
	def addTeam: name {
		if: teams.length >= CONSTANTS.TEAM_AMOUNT 
		then: {
			raise: XMaximumTeamsReached.new("This game already has enough teams!");
		} else: {
			changeOccured := true;
			teams := teams + [team.new(name)];
		};
	};
	// Creates a team for each entry in a table
	def addTeams: names {
		foreach: {|t| addTeam: t} in: names;
	};

	// Updates all the teams
	def updateTeams: teamArray {
		def changeOccured := false;
		teamArray.length.doTimes: { |i|
			changeOccured.or:{self.teams[i].updateTeam: teamArray[i]};
		};
		if: changeOccured then: {
			self.changeOccured := true;
		};
	};

	// Generate a unique ID
	// the unique id is made out of the device id and a timestamp.
	// this guarantees no games can have the same id even if they are 
	// created at the exact same time.
	def generateID(deviceID) {
		def time := /.at.support.timer.now().toString(); 
		deviceID + "-" + time;
	};
} taggedAs: [Game];

/***************
 * Export List *
 ***************/

 object: { 
	def game := game;
	def Game := Game;
	def ActiveGame := ActiveGame;
	def ResolvedGame := ResolvedGame; 
};