// importer.at
// Mathijs Saey
// The import module is responsible for finding and joining games.

import /.at.lang.exceptions;
import /.at.lang.futures;

import /.weScrabble.local.game;
import /.weScrabble.local.team;
import /.weScrabble.local.player;

// Exceptions
deftype InvalidIndexEception <: lobby.at.lang.types.Exception;
def  XInvalidIndexEception := createException(InvalidIndexEception);

/************       
 * Importer *
 ************/

def importer := object: {
	def subscriptions := [];
	def gameNames := [];
	def games := [];

	// Cancels all current subscriptions
	def endSearch() {
 		foreach: { |s|
 			 s.cancel();
 		} in: subscriptions;
 		subscriptions := [];
 	};

 	// Join game at index
 	def joinGame(idx, localPlayer) {
 		def resGame := clone: game;
 		def gameRef := games[idx];
 		resGame.localPlayer := localPlayer;

 		//Ensure the game is currently reachable
 		if: gameRef == 0 then: {
 			raise: XInvalidIndexEception.new("No valid player found at idx " + idx);
 		};

 		// Get some data about the remote game
 		def futureID := gameRef<-id()@TwoWay;
 		def futureName := gameRef<-name()@TwoWay;
 		def futureTeams := gameRef<-teams()@TwoWay;

 		// Store the remote data once possible
 		when: futureID 		becomes: {|id| resGame.id := id};
 		when: futureName 	becomes: {|n| resGame.name := n};
 		when: futureTeams 	becomes: {|t| resGame.teams := t;
 			resGame.teams[localPlayer.teamIdx()].addPlayer: localPlayer;
 		};

 		// Add localplayer to the remote game 
 		// TODO: should contain a way to ensure player got added to remote game
 		gameRef<-addPlayer: localPlayer withIdx: localPlayer.teamIdx();

 		// Stop looking for new games
 		self.endSearch();

 		resGame;
 	};

 	// Start looking for available games
 	def search() {
 		// Ensure we only have one active search going
 		if: subscriptions == [] then: {
 			system.println("IMPORTER: Searching...");

 			// When discovering a game, ensure we haven't stored it before
 			subscriptions := subscriptions + [
 			whenever: ActiveGame discovered: { |game|
 			if:  !games.contains(game) then: {
 				system.println("IMPORTER: New game discovered!");
 				def nameF := game<-name()@TwoWay;
 				def name;
 				def idx;

 				when: nameF becomes: {|n|
 					name := n;
 					system.println("IMPORTER: name: " + n);
 					gameNames := gameNames + [name];
 					games := games + [game];
 					idx := games.length;
 				};

 				subscriptions := subscriptions + [
 				whenever: game reconnected: {
 					if: name == nil then: {
 						system.println("IMPORTER: unkown game reconnected");
 					} else: {
 						system.println("IMPORTER: " + name + " reconnected");
 						gameNames[idx] := name;
 					};
 					games[idx] := game;
 				}];

 				subscriptions := subscriptions + [
 				whenever: game disconnected: {
 					if: name == nil then: {
 						system.println("IMPORTER: unkown game disconnected");
 					} else: {
 						system.println("IMPORTER: " + name + " disconnected");
 						gameNames[idx] := gameNames[idx] + " <Disconnected>";
 						games[idx] := 0;
 					};
 				}];
 			}}];
 		};
 	};
};

/***************
 * Export List *
 ***************/

object: {
	def importer := importer;
};